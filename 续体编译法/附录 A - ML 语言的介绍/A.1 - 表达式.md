ML 中的表达式具有如下形式：

- $exp\to id$ <br/>
    表达式可以是一个单独的标识符。ML有两类标识符：包含字母如 `A-Z` `a-z` 和数字与符号如 `0-9` 和 `'`（不能在开头）的字母类标识符；以及由任意 ``!%&$+-/:<=>?@\~\^|#`*`` 以任意组合构成的符号类标识符。有一些标识符是关键字，比如 `let` 和 `end`，`|` 和 `=>`。
- $exp\to exp~~id~~exp$ <br/>
    一个中序算符必须被放在两个表达式中间，比如说 `a+b` 或 `(a+b)*c` 或 `a*b+c`。不同的算符有不同的优先级，正如 Pascal 和 C 中的一样。但不同的是，在 ML 中，任何标识符都能被声明为中序的并被赋予优先级，比如 `+` 和 `*` 只不过是默认被赋予中序的普通标识符罢了。
- $exp\to(~~exp~~)$ <br/>
    表达式可以被圆括号包裹而不改变其语义，正如 C 中一样，这被用于指明优先级。
- $exp\to expr~~exp$ <br/>
    函数作用在 ML 中仅仅是将参数写在函数的后面，因此 `f x` 就是将函数 `f` 作用到 `x` 上。可以写成 `f(x)`使得这部分语法像 C，但是这个括号是毫无必要的，你也可以写成 `(f)x`。如果 `g y` 的结果仍然是一个函数，那么你可以写 `(g y) x` 或者 `g y x`，因为函数作用是左结合的。同样，任何函数的参数也可以是函数调用比如 `f(g y)`。每个 ML 中的函数都只接受且必须接受一个参数。
- $exp\to id\\exp\to id~~exp\\exp\to exp~~id~~exp$ <br/>
    并集类型的值可以被三种方式构造，其一是使用常量构造子，其二是使用携带其它值的构造子。对于携带了值的构造子，只要其携带的值是一个二元有序对，就能被定义为中序的，此时这类构造子能被写在其两个参数中间。列表构造子 `::` 就符合这种情况：比如说 `3::nil` 是只有一个元素的列表，而 `::` 被定义为右结合的，因此 `1::2::3::4::nil` 是一个具有四个元素的列表。
- $exp\to(~~exp~~,~~exp~~)\\exp\to(~~exp~~,~~exp~~,~~exp~~)$ <br/>
    在 ML 中，将两个或多个表达式以逗号分隔并写在一对圆括号中将构造一个 $n$ 元有序对。当这个表达式被计算时，内存上将建立一个对应的结构体。这有点像 Lisp 的 `cons` 或者 Pascal 的 `new`。`(3, "a", 7)` 是一个有一个整数、一个字符串、一个整数构成的三元有序对，与此相区别，`((3, "a"), 7)` 是一个由二元有序对与一个整数构成的二元有序对。尽管 ML 中有对于函数参数数量的限制，但等价于其它语言中多参数函数的行为，可以传递 $n$ 元有序对来实现，如 `f(x, y)`。
- $exp\to\{~~exprow~~\}\\exprow\to id~~=~~exp\\exprow\to exprow~~,~~id~~=~~exp$ <br/>
    记录体表达式是一系列包围在花括号中的带有对应名称的成员表达式。成员的名称不需要提前声明。
- $exp\to\text{let}~~dec~~\text{in}~~exp~~\text{end}$ <br/>
    `let` 表达式引入一系列本地定义 $dec$，使其仅仅可见于 `let` 和 `end` 之间。$dec$ 的具体形式将在 A.3 小节给出。
- $exp\to\text{fn}~~pat~~\Rightarrow~~exp$
- $exp\to\text{fn}~~match$
- $match\to rule\\match\to match~~|~~rule\\rule\to pat\Rightarrow exp$
- $exp\to\text{case}~~exp~~\text{of}~~match$