ML 中的表达式具有如下形式：

- $exp\to id$ <br/>
    表达式可以是一个单独的标识符。
    ML有两类标识符：包含字母如 `A-Z` `a-z` 和数字与符号如 `0-9` 和 `'`（不能在开头）的字母类标识符；
    以及由任意 ``!%&$+-/:<=>?@\~\^|#`*`` 以任意组合构成的符号类标识符。
    有一些标识符是关键字，比如 `let` 和 `end`，`|` 和 `=>`。
- $exp\to exp~~id~~exp$ <br/>
    一个中序算符必须被放在两个表达式中间，比如说 `a+b` 或 `(a+b)*c` 或 `a*b+c`。
    不同的算符有不同的优先级，正如 Pascal 和 C 中的一样。
    但不同的是，在 ML 中，任何标识符都能被声明为中序的并被赋予优先级，
    比如 `+` 和 `*` 只不过是默认被赋予中序的普通标识符罢了。
- $exp\to(~~exp~~)$ <br/>
    表达式可以被圆括号包裹而不改变其语义，正如 C 中一样，这被用于指明优先级。
- $exp\to expr~~exp$ <br/>
    函数作用在 ML 中仅仅是将参数写在函数的后面，因此 `f x` 就是将函数 `f` 作用到 `x` 上。
    可以写成 `f(x)`使得这部分语法像 C，但是这个括号是毫无必要的，也可以写成 `(f)x`。
    如果 `g y` 的结果仍然是一个函数，那么可以写 `(g y) x` 或者 `g y x`，因为函数作用是左结合的。
    同样，任何函数的参数也可以是函数调用比如 `f(g y)`。
    每个 ML 中的函数都只接受且必须接受一个参数。
- $\begin{aligned}&exp\to id\\&exp\to id~~exp\\&exp\to exp~~id~~exp\end{aligned}$ <br/>
    并集类型的值可以被三种方式构造：
    其一是使用常量构造子，其二是使用携带其它值的构造子。
    对于携带了值的构造子，只要其携带的值是一个二元有序对，就能被定义为中序的，
    此时这类构造子能被写在其两个参数中间。列表构造子 `::` 就符合这种情况：
    比如说 `3::nil` 是只有一个元素的列表，而 `::` 被定义为右结合的，
    因此 `1::2::3::4::nil` 是一个具有四个元素的列表。
- $\begin{aligned}&exp\to(~~exp~~,~~exp~~)\\&exp\to(~~exp~~,~~exp~~,~~exp~~)\end{aligned}$ <br/>
    在 ML 中，将两个或多个表达式以逗号分隔并写在一对圆括号中将构造一个 $n$ 元有序对。
    当这个表达式被计算时，内存上将建立一个对应的结构体。
    这有点像 Lisp 的 `cons` 或者 Pascal 的 `new`。
    `(3, "a", 7)` 是一个由一个整数、一个字符串、一个整数构成的三元有序对，
    与此相区别，`((3, "a"), 7)` 是一个由二元有序对与一个整数构成的二元有序对。
    尽管 ML 中有对于函数参数数量的限制，但等价于其它语言中多参数函数的行为，
    可以传递 $n$ 元有序对来实现，如 `f(x, y)`。
- $\begin{aligned}&exp\to\{~~exprow~~\}\\&exprow\to id~~=~~exp\\&exprow\to exprow~~,~~id~~=~~exp\end{aligned}$ <br/>
    记录体表达式是一系列包围在花括号中的带有对应名称的成员表达式。
    成员的名称不需要提前声明。
- $exp\to\text{let}~~dec~~\text{in}~~exp~~\text{end}$ <br/>
    `let` 表达式引入一系列本地定义 $dec$，使其仅可见于 `let` 和 `end` 之间。
    $dec$ 的具体形式将在 A.3 小节给出。
- $exp\to\text{fn}~~pat~~\Rightarrow~~exp$ <br/>
    关键字 `fn` 读作 $\lambda$，定义的是匿名函数。
    语法符号 $pat$ 表示的是 *模式*；对此有一个简单的例子，即单个标识符（下面会介绍）。
    比方说 `fn x => x + 3` 是一个将三加到其参数上的函数。`(fn x => x + 3) 7` 是 $10$。<br/>
    $\lambda$ 表达式是可以嵌套的，`fn x => fn y => x + y` 是一个返回函数的函数。
    ML 使用的是静态作用域，因此 `(fn x => fn y => x + y) 7` 与 `fn y => 3 + y` 在所有情况下都等价。
    嵌套 $\lambda$ 表达式提供了另一种书写多参数函数的手段，
    比如 `fn x => fn y => fn z => x + y + z` 等价于一个三参数函数，使用方式是 `f a b c`。
    这种情况下 $f$ 被称为“柯里化”的函数。<br/>
    实际上，`fn` 表达式的语法比上面说的还要丰富，因为还有下面这个语法：
- $exp\to\text{fn}~~match$ <br/>
    $match$ 是一系列用竖线 $|$ 分割的匹配规则。
- $\begin{aligned}&match\to rule\\&match\to match~~|~~rule\\&rule\to pat\Rightarrow exp\end{aligned}$ <br/>
    如果函数以多条规则定义，当被作用于变量时，每条规则的模式会被依次检验，第一个符合的模式所对应的规则会被执行。
- $exp\to\text{case}~~exp~~\text{of}~~match$ <br/>
    `case` 表达式先计算 $exp$，然后依次尝试用 $match$ 中的规则对计算结果进行匹配。第一个匹配的模式对应的规则会被执行，有关变量（如果有）会先被绑定。
