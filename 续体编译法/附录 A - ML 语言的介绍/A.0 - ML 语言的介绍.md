本附录包含足以令读者理解本书其他部分的 ML 语言知识。我们将只介绍 ML 语言的核心部分（除去模块系统，尽管 4.8 节提及了模块系统）。对更全面的 ML 语言，请参考 Stanrard Meta Language 的标准定义。

数据结构是 Standard  ML 语言的特色之一。正如其他语言中有基础类型（如整数）、笛卡尔积类型（如结构体）、以及不交和类型（如 Pascal 中的 `variant` 或 C 中的 `union`），在 ML 里，这些类型被设计得更安全与优雅。

基础类型，包括整数类型 `int`、浮点数类型 `real`、以及字符串类型 `string`（$0$ 个或更多个字符的序列）。

对于给定类型 $t_1,t_2,\ldots,t_n,(n>2)$，能构造笛卡尔积类型 $t_1\times t_2\times\ldots\times t_n$。（在 ML 的记号体系中，符号 $\times$ 以星号 `*` 表示。）这被称为 $n$ 元有序对。比如，`int*int*string` 是一个包含了形如 `(3,6,"abc")` 的值的三元有序对。

记录体（record）类型相当于给予了有序对的每一个成员一个名称。例如类型

```sml
{wheels: int, passengers: int, owner: string}
```

包含了如下值：

```sml
{wheels=4, passengers=6, owner="Fred"}
```

尽管与类型 `int*int*string` 很像，但有序对和记录体在 ML 中是两个不同的类型。

并集（union）类型可以具有几种不同形式的值；比如，一个 `list` 类型的值可能是一个 `pair` 或一个 `nil`。与 C 的 `union` 或 Pascal 的 `variant` 不同，ML 需要用户为每个值标记一个标签以区分其具体类型。在检查具体的标签之前，从并集类型中提取任何内容都是不可能的。ML 以此保证并集类型的安全性。（在 ML 中，这种标签被称为构造子。）

`datatype` 关键字被用于声明并集类型。一个 datatype 声明需要列出所有构造子的名称以及对应的类型。例如：

```sml
datatype vehicle =
      CAR of {wheels: int, passengers: int, owner: string}
    | TRUCK of real
    | MOTORCYCLE
```

按此定义，每个 `vehicle` 类型的值可能为 `CAR`、`TRUCK`、或 `MOTORCYCLE` 中的一种。如果是一个 `CAR`，它将携带一个记录体类型的值；如果是一个 `TRUCK`，它将携带一个浮点数值，以表征其重量；至于 `MOTORCYCLE` 则是一个常量构造子，不携带参数。

类型可以是多态的：函数或构造子能作用于相似但实际上不同的类型的元素上。比如说，`list` 数据类型可以被用于产生整数的列表、浮点数的列表、整数列表的列表等。其定义如下：

```sml
datatype 'a list = nil | :: of 'a * 'a list
```

符号 `::` 与前面的 `TRUCK` 或 `nil` 是一样的，仅仅是一个标识符。在类型名称 `list` 前的类型变量 `'a` 表示 `list` 不是一个普通类型，而是一个必须作用于其他类型如 `int` 或 `string` 后才有意义的类型构造器。类型构造器是向左作用的，因此整数列表的类型是 `int list`。

构造子 `::`（读作 cons）携带的值的类型是 `'a * 'a list`，即，一个第一个元素的类型为 `'a` 而第二个元素的类型为 `'a` 的列表的二元有序对。因此，如果我们有一个字符串列表，其第一个元素是一个字符串，而第二个元素将是另一个字符串列表。（或称列表的尾部。）

尽管 `'a` 可以表达任意类型，比如可以构造 `int list list`，但对于一个具体的 `list`，所有的元素都得是同一个类型。如果实在需要在一个 `list` 中放下不同类型的东西，就需要使用一个并集类型来作为 `list` 的参数了。比如说 `vehicle list` 就既能包含 `CAR` 也能包含 `TRUCK`。

大部分的数据结构都具有不变性：它们的值不能被赋值语句改变。比如，假设一个变量 `a` 的值是一个表征 Fred 的六座客车的的记录体（正如前面的例子），那么没有任何手段可以将 `a` 改为七座客车，或修改 `a` 本身。所能做的只有构造一个全新的记录体，如：

```sml
{wheels=4, passengers=7, owner="Fred"}
```

然后将它绑定到变量 `b` 上。

然而，对这条规则有一个例外。有一个特殊的数据类型用于表述可变的引用：

```sml
datatype 'a ref = ref of 'a
```

这是一个具有特殊性质的内置类型，与 `list` 不同，是不能被用户定义的。比如说，如果 `r` 是一个引用变量，如一个 `int ref` 类型的变量，那么 `r` 可以被（用 `:=` 操作符）赋值以储存一个不同的值。如果一个记录体或有序对的成员是引用，比如说：

```sml
{wheels=4, passengers=ref 6, owner="Fred"}
```

那么对应的成员就能被赋值。此例子中记录体的类型是：

```sml
{wheels: int, passengers: int ref, owner: string}
```

已经与原本的定义不同。