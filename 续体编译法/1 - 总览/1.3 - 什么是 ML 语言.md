本书将以真正的编译器的实现来介绍续体编译法以及续体传递形式上的优化。
尽管我们实现的是 ML 编译器 Standard ML of New Jersey，
但续体传递模式本身并非 ML 独有，在许多其他语言的编译过程中也有使用。

ML 语言源自 1970 年代爱丁堡的 LCF 定理证明系统的元语言，并在 1980 年代成为独立语言，拥有了独立的 ML 语言系统。
从这个时间点开始，标准 ML 语言包括其形式化语义有了完整而严谨的的定义，多个 ML 编译器得以实现，几百位 ML 程序员开始活跃地使用这门语言。

ML 作为实用编程语言有如下优点：

- ML 是严格求值的。
  函数调用时传递参数总是先于调用的发生而被计算，正如 Pascal、C、Lisp、与 Scheme 中的情况，
  这与 Miranda 或 Haskell 不同，因为 Miranda 和 Haskell 是懒惰求值的。
- ML 具有高阶函数。
  这意味着函数能作为参数传递，也能作为返回值被返回。
  这正如 Scheme、C、Haskell 中的一样，而与 Pascal 和 Lisp 不同。
  但与 C 具有差异的是，ML 允许嵌套函数定义（Scheme 和 Haskell 也有），这使得高阶函数有用得多。
- ML 具有参数化多态类型。
  这意味着函数能够被应用于不同类型的参数，只要函数内所做的事情不随类型的不同而不同。
  Lisp、Scheme、Haskell 也具有参数化多态，而 Pascal 和 C 没有。
  参数化多态和重载是两回事。函数重载允许函数针对不同类型实现多次，正如 C++ 的情况。
- 类型检查是静态的，即在编译期完成。
  这使得运行时不需要进行类型检测。（这也使得许多漏洞能在程序被运行前就被发现。）
  Pascal、Ada、C、Haskell 的类型检查也是静态的，而 Lisp、Scheme、Smalltalk 的类型检查是动态的（发生在运行期）。
  在此基础上 ML 和 Haskell 有类型推导，这减轻了程序员手动进行类型标注的负担。
  像 Pascal、C、Ada、和其他派生于 Algol 的语言则都需要程序员手动对每个变量进行明确的类型标注。
- ML 具有垃圾回收机制，即自动回收所有内存上的不可达的资源。
  这对于函数式语言来说是典型的，比如像 Scheme 和 Haskell 也有垃圾回收机制。
  对于非函数式语言，Lisp 和 Smalltalk 也具有垃圾回收机制，而像 Pascal、C、Ada 这种语言则通常没有。
- ML 具有副作用：输入/输出，对引用的赋值和更新。
  在这方面它更像大部分语言（如 Pascal、C、Smalltalk、Lisp、Scheme）而不同于那些纯函数式语言比如 Haskell。
  然而，在 ML 中，可以被更新的变量和数据结构是受限的，并且能被编译期的静态的类型推断检测出来。
  因此对于任何特定的程序而言，大部分的变量和数据结构都是不变的。
- ML 的语义是有完整的形式化的定义的。
  这就意味着所有合法的 ML 程序都具有确定的运行结果，而所有不合法的程序都能被编译器识别出来。
  这就和 Ada 十分不同，因为后者尽管具有形式化的定义但不完整，一些「错误」的程序也能被编译器接受，
  而 Pascal 更是具有一定的「歧义与不安全性」。C 在这方面更是以指针的随意和破坏性而著称，
  倒是在这个方面 Lisp 和 Scheme 表现不差。原则上，任何错误的程序都应该在编译期或运行期被检测出来，
  尽管某些事情是未定义的，比如函数调用参数的计算顺序。

从以上总结中我们可以看出，有许多我们的编译器需要实现和考量的语言特性和问题是其他编译器也会遇到的，
并且对于近代语言的编译器比如 ML 的编译器应该具有某些和传统语言比如 C 的编译器所不同的特性。

比如对于 ML（以及 Smalltalk、Scheme 之类）的高阶函数而言，编译器必须引入额外的运行时结构来表达这些函数中的自由变量。
而由于这些所谓「闭包」的生命周期往往不是在编译期能够决定的，一些特定的垃圾回收手段就需要被引入。

垃圾回收机制则会引入额外的要求，如所有的运行时数据结构都得是某种垃圾回收器能够识别的形式，
这包括编译后的代码所使用的机器寄存器以及其他中间量。

由于 ML 所推荐的编程风格是函数式的，这就意味着比起更新旧的数据，程序员更倾向于产生新的数据。这就意味着垃圾回收器必须非常有效率。
对比于此，在某些更老的 Lisp 体系里或者某些带垃圾回收的 Algol 的派生语言里，垃圾回收器所承受的压力要小很多，因为它们更少分配新的对象。

大部分的控制流都被表达于源代码中的函数调用（而不是像 `while` 和 `repeat` 这种内建结构）。
因此函数调用，尤其是尾递归调用，就必须不能引入太大的性能负担。

ML 里没有「宏」。C 和 Lisp 常用宏来对常用代码片段进行内联展开，而在 ML 里，一个好的编译器应该识别并进行函数的内联展开。这比使用宏更安全而有效。

对于 ML 来说，一大特点是数据结构的不可变性，即任意变量，如列表的一个元素或堆上的一个结构体，一旦创建就不能再被改变。
当然，对于一个函数的本地变量来说，每次该函数被调用的时候，这些本地变量都能被使用不同的值重新初始化。
对于堆上的数据结构，如旧的链表的节点，最终都会在新的节点被创建的时候变成垃圾（因为不再有本地变量指向它们了），
但数据结构的不可变性保证「别名问题」可以被平凡地解决。设想一个传统的语言的如下语句：

$$
a\leftarrow\sharp1(p);\quad\sharp1(q)\leftarrow b
$$

（此处 $\sharp1(x)$ 表示从一个结构体 $x$ 中提取第一个元素）
由于 $p$ 和 $q$ 可能是别名关系，即实际上是同一个物品，因此这两语句是不可以交换的。相似地：

$$
a\leftarrow\sharp1(p);\quad b\leftarrow f(x)
$$

也是不可以交换的，除非关于 $f(x)$ 的行为已知。

在 ML，可变的数据结构，即在创建后仍然能被修改的数据结构，有与不可变的数据结构所不同的类型。
因此，编译器在类型检查阶段就能区分可变与不可变的变量和数据结构，且通常大部分的变量和数据结构都是不可变的。
这使得别名问题基本上消失了，因为只要一个变量具有不可变性，任何对该变量的读取都不会影响其他的操作，所有的操作都会是可交换的。
我们的编译器在许多方面大量利用了这个性质。

对于惰性求值的语言比如 Haskell，所有结构的不可变性都是默认的。
然而事实上，用一个计算后的结果来更新某个变量，这和允许可变性在编译器或运行时的眼中看起来是很相似的。

总而言之，ML 具有更加抽象的形式化语义。这在某些方面非常有用，比如对可计算函数的表示上的任意优化或改变，都能产生合法的程序。
与之对比的是 C，C 没有形式化的语义。即使对一段 C 程序的行为能产生什么直观上的理解，这种理解也往往和低层次的机器指令或布局有关。
这使得 C 程序即使使用了未定义行为，在任何「良好的」编译器面前，也应该能编译通过，甚至产生程序员所期望的结果。
在这种情况下，编译器所能做的事情就很少了。
