将程序员从为中间变量命名的麻烦中解放出来正是 FORTRAN 语言之所以在表达能力上优于汇编语言的原因。比如说这使得我们可以写出 $x=(a+b)*(c+d)$ 这样的代码，而不是像汇编语言那样的：

$$
\begin{aligned}
r_{1}&\leftarrow a+b\\
r_{2}&\leftarrow c+d\\
x&\leftarrow r_{1}\times r_{2}
\end{aligned}
$$

这种简洁的、只有一行的表达式比起三行的汇编语言程序更加容易阅读，因为 $r_{1}$ 和 $r_{2}$ 这样的名字对我们的理解毫无帮助。
不仅如此，汇编程序还明确地指定了计算的顺序如例子中 $a+b$ 的计算在 $c+d$ 之前被执行，这部分信息同样是我们所不关心的。

对于函数，$\lambda$ 演算同样给予了我们类似的优势。我们可以直接写 $f\left(\lambda x.x+1\right)$，而不是像 Pascal 中的：

```pascal
function g(x: integer): integer;
    begin g := x+1 end;
... f(g) ...
```

在这里，Pascal 强制我们为 `g` 这个函数命名，而这个名字以及为了这个名字所进行的啰嗦的定义对我们理解代码本身毫无帮助。
与此对比，$\lambda$ 演算使我们可以不用在意函数的计算顺序，甚至不用在意跨越了函数调用边界的计算顺序。

这些便利对于写程序的人类来说是极好的，但对于需要处理程序代码的编译器来说，要考虑的就多了。比如说对于程序中的每一个中间值，编译器都需要定一个独一无二的名字，这样它才能处理名称查找、寄存器分配、指令调度等工序。

续体传递形式（Continuation-Passing Style, CPS）是一种将程序中所有控制流和数据流都显化的程序代码形式。
它的优点和柯奇的 $\lambda$ 演算很像，比如定义良好且容易理解。

我们暂且使用如下例子对续体传递形式进行一个不那么正式的介绍：

```sml
fun prodprimes(n) =
    if n = 1
    then 1
    else if isprime(n)
         then n * prodprimes(n-1)
         else prodprimes(n-1)
```

这段 ML 语言的程序计算的是全体小于等于一个给定的正整数 $n$ 的质数的积。
其中，关键字 `fun` 表示这部分代码是一个函数定义，等号右手侧的表达式是函数的值。
至于 `if-then-else` 和算术运算，相信大部分读者都不陌生。

对这段程序的控制流，有几个关键节点是需要名字的。
比如说，当函数 `isprime` 被调用的时候，一个所谓的「返回地址」
^[在 C 语言，编译器一般通过在栈上储存这个返回地址，这部分区域被称为帧（frame），译者注。]
也会被一并传递过去，我们暂且命名这个地址为 `k`；同时 `isprime` 这个函数会返回一个布尔值，我们暂且称之为 `b`。
在函数体中第一个对 `prodprimes` 的调用（在第二个 `if` 的 `then` 语句内的那个）将携带一个整数 `p` 作为返回值，返回到其调用点 `j`；
但第二个对 `prodprimes` 的调用（在 `else` 语句里的那个）将携带一个整数 `q` 作为返回值，返回到调用点 `h`。
第一个 `n - 1` 将产生一个临时变量 `m`，而第二个 `n - 1` 会产生一个临时变量 `i`，以此类推。

同时注意到，当 `prodprimes` 被调用时，它是获得了一个返回地址的，我们暂且称之为 `c`，并把这个 `c` 也当成函数参数的一部分。
这样，当我们需要从这个函数返回的时候，就等价于直接使用这个 `c`。

以上所有表述都能以「续体」的形式表达。所谓续体，就是一个表征“接下来做什么”的函数。
例如我们可以把对 `prodprimes` 的调用看成是从参数中传递了一个续体 `c`，并在完成计算之后把 `c` 作用到计算结果 `a` 上。
由此，从函数中返回的行为和继续进行函数调用看起来就是等价的了！

这个程序可以被重写到如下续体传递形式上。对于不熟悉 ML 的读者，只需注意到 `let` *声明* `in` *表达式* `end` 声明的是本地变量（一个函数、一个整数之类），其作用域只包括 *表达式*。并且需要注意到 `let` 语句的值等价于其 *表达式* 部分的值。
同时需要注意到 `fun` 声明的是函数，而 `val` 声明是将值绑定到变量名上。

```sml
fun prodprimes(n, c) =
    if n = 1
    then c(1)
    else let fun k(b) = if b = true
                        then let fun j(p) = let val a = n * p
                                            in  c(a)
                                            end
                                 val m = n - 1
                             in  prodprimes(m, j)
                             end
                        else let fun h(q) = c(q)
                                 val i = n - 1
                             in  prodprimes(i, h)
                             end
         in  isprime(n, k)
         end
```

很容易注意到，所有上述讨论中出现的控制流的关键点 $c,k,j,h$ 都只是续体函数，
而所有的变量名 $b,p,a,m,q,i$ 都只是普通的值。
并且我们不需要做太多改动就能得到续体传递形式，我们只是限制了对现有语言的一些特性的使用。
对于详细的续体传递形式的解释将在第二章与第三章给出。

对于优化编译器来说，续体传递形式极其利于对程序本身的操纵和变换。
比如说如果我们要做尾递归消除优化，即：
如果函数 $f$ 中所干的最后一件事是调用了函数 $g$，
那么比起让 $g$ 返回到 $f$ 内部，不如让 $g$ 直接返回到 $f$ 被调用的地方。
在续体传递形式下，这就等价于直接把 $f$ 被调用时传入的续体直接传递给 $g$。

观察 `prodprimes` 的原版代码，显然其内部对自身的最后一个递归调用是尾递归的。
在续体传递形式下，这个事实已经通过 $h$ 表现出来了：$h(q)=c(q)$。
由此，显然 `h` 和 `c` 是等价的。由此，对如下片段：

```sml
let fun h(q) = c(q)
    val i = n - 1
in  prodprimes(i, h)
end
```

$h$ 已经不需要了，直接将它替换成 $c$ 如下：

```sml
let val i = n - 1
in  prodprimes(i, c)
end
```

这事实上就是尾递归消除。
