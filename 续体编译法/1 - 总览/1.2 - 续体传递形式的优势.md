续体传递形式作为编译和优化的中间表示有许多优势，这里我们将它和如下几位竞争对手相比较：

- $\lambda$ - $\lambda$ 演算（没有显示续体传递的 $\lambda$ 演算）；看起来是考虑 ML 和 Scheme 这类函数式语言的最佳选择。
- QUAD - 寄存器转移形式，又称“四元组”；是简单冯纽曼机器的直接近似表达。
- PDG - 程序依赖图；能同时表达控制流与数据流而又不至于使双方过度互相依赖。
- SSA - 静态单赋值形式；被特定设计从而使得特定的数据流分析算法效率最大化的形式。
  在静态单赋值形式，所有变量恰好被赋值一次，使用显式的数据转移函数 $\Phi$ 维持控制流合并时“单赋值”的表象。
  静态单赋值形式与续体传递形式在很多方面有相似之处，续体传递形式也部分地具有静态单赋值形式的性质。

这些中间表示都是为了实现特定的程序变换而设计的。不妨考虑一些程序优化的过程，以便对比它们实现上的难易程度和效率。

### 内联展开

$\lambda$ 演算的变量绑定规则和作用域规则就是为了内联展开设计的，
它只需要直接用函数体替换所有的函数调用并且将所有形式参数用调用时的表达式替换掉就可以了。
但对于严格的按值调用的语言来说，比如 ML、Pascal、Lisp、Scheme、Smalltalk 之类，
$\lambda$ 演算的 $\beta$ 展开仅仅是将实际参数复制一份到形式参数上，这就意味着：

- 一个在严格求值下会陷入无限循环的程序现在会中止。
- 一个在源程序中只会计算一次的实际参数现在可能会被计算好几次。
- 对于容许副作用的语言如 ML、Pascal、Lisp 之类，实际参数计算时本该发生一次的副作用可能发生多次也可能不发生。

而对于续体传递形式来说，表达替换并不比 $\lambda$ 演算的更困难，并且以上的缺点一个都不会出现。
在续体传递形式中，所有被函数作用于的实际参数要么是变量要么是常量，绝不会是任何非平凡的子表达式。
因此以实参替代形参不会造成任何后果。

而对于其他中间表示形式而言，如 QUAD、PDG、SSA，则主要将关注点集中于单个函数体内，而不是跨越多个函数的边界的优化。
基于它们的内联展开在增加对函数参数以及调用链的描述机制的时候仍然可能实现，但它们没有解决计算终止性与副作用乱序的问题。

### 闭包表示

有的语言具有“块结构”或“嵌套函数”，比如 Pascal、Scheme、ML，
使得在这些语言中，函数 $f$ 可能被定义在另一个函数 $g$ 的内部，
不妨进一步假设 $g$ 被定义在函数 $h$ 的内部，此时 $f$ 中能够访问的变量除了它自己的参数和变量，
还有 $g$ 和 $h$ 中的参数和变量。对此，编译器的任务之一就是有效率地实现这种对外层函数变量的访问。
$\lambda$ 演算和续体传递形式本身就支持这类带嵌套作用域的函数，
因此使用这两种中间表示形式的编译器十分易于处理这类函数以及为其选择访问外层作用域的变量的最优手段。
但对于其他中间表示形式来说，这个问题就比较困难了。

### 数据流分析

数据流分析涉及值在流程图上的静态传播（更准确的说，数据流分析关注的是使用编译期占位符替代运行期的值以考察数据的流动）。
它主要着眼于变量的定义在变量的使用处是否可达的问题，这个问题是进行某些优化的关键。
续体传递形式是程序控制流的忠实表达，在续体传递形式上的数据流分析总是会比在传统中间表示如四元组上的数据流分析要容易。

静态单赋值形式就是为了前向数据流分析的高效而设计的，因此它尤其擅长于识别变量的定义在使用处的可达性，
因为在这个形式中每个变量都只被定义和赋值一次。
在后续讨论中，本书将会介绍续体传递形式在此方面具有和静态单赋值形式极其相似的性质。而与此相反，$\lambda$ 演算对于数据分析并不合适。

### 寄存器分配

对于将程序中的变量分配到机器的寄存器上的问题，一套能体现变量生命周期（变量的产生与失效的时机）的中间表达形式十分重要。
生命周期分析实际上是数据流分析中的一种，因此前一段的内容对本段也适用。值得一提的是，在本书实现的使用续体传递形式的编译器中，
在特定的一些编译阶段里，续体传递形式中的变量与寄存器是对应的。

### 向量化

程序依赖图形式就是为了这类从普通循环中产生向量化指令的优化而设计的。
在其他中间表达中，向量化优化仍然可能被实现，但和程序依赖图形式相比往往需要更多附加信息。

### 指令调度

现代计算机是高度流水线化的，因此编译器后端需要进行指令调度来避免运行期的流水线阻塞。
指令调度需要对每条指令的大小、时机、资源依赖都有极其细致的掌控。
本节提及的中间表示形式对于这个阶段的优化都过于抽象了。

结论：

本节提到的中间表示形式之间具有许多异同，如静态单赋值形式只是四元组的一个限制版本，而续体传递形式也不过是 $\lambda$ 演算的一个限制版本。
事实上，静态单赋值形式与续体传递形式也具有很多相似之处，比如续体传递形式中的变量也只被绑定一次。
而续体的概念提供了易于实现的 $\lambda$ 演算的参数替换，同时提供了适用于冯纽曼机器的数据流与寄存器分析。
